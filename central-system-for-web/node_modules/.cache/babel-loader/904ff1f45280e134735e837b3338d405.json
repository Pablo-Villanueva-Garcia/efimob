{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nconst hostname = 'http://localhost:8000';\n/*El options nos permite aplicar los headers a las llamadas asegurandonos de que nuestra comunicacion\r\nes en JSON */\n\nconst options = {\n  headers: {\n    'Content-Type': 'application/json',\n    'Accepts': 'application/json'\n  }\n};\n/*como se repite la misma estructura practicamente en todos los procesos hemos \r\ncreado un UseGET con ella */\n\nexport const UseGet = url => {\n  _s();\n\n  const [response, setResponse] = useState();\n  useEffect(() => {\n    fetch(hostname + url, {\n      method: 'GET',\n      ...options\n    }).then(response => response.json()).then(response => {\n      setResponse(response);\n    });\n  }, [url]);\n  return response;\n};\n/* 1* uso del get sin el useget para tener como referencia */\n\n/*\r\nexport const UseGetRecipesList = () => {\r\nLa forma mas basica de traernos el contenido de la api es utilizando un usestate \r\npara recoger valores y  un useeffect para ejecutar el fetch y dando el valor de \r\nla response al set \r\n\r\nconst [response,setResponse]=useState();\r\nuseEffect ( () => {\r\n        fetch('http://localhost:8000/recipes',\r\n        {\r\n            method:'GET',\r\n            ...options,\r\n        }).then(response => response.json())\r\n        .then(response => {\r\n            setResponse(response);\r\n            \r\n        })\r\n    },[]);\r\n    return response;\r\n}\r\n\r\n*/\n//GET usando useget y implementando el buscador de keywords\n\n/*2 uso del useget en get recipes export const UseGetRecipesList = () => UseGet('/recipes');\r\n}\r\nexport const UseGetRecipesList = (keywords) =>{\r\n    let url = '/recipes';\r\n    if(keywords){\r\n     url =  url + '?keywords=' + keywords;\r\n    }\r\n    return UseGet(url);\r\n}\r\n*/\n//3* uso del usegetrecipes para trabajar correctamente con las urls y gestion de errores \n\n_s(UseGet, \"WYJMalD1OXyA3NQCMZtroVUOh7E=\");\n\n_c = UseGet;\nexport const UseGetRecipesList = listparams => {\n  let url = '/recipes';\n\n  if (listparams) {\n    //metodo elaborado usando Object ,encode y reduce\n    //const querystring = Object.keys(listparams).map(key => key +'='+ encodeURIComponent(listparams[key])).redude((a,b) => a +'&'+ b)\n\n    /*el const params recomponemos el objeto , primero sacamos las claves , segundo en un filter excluimos las undefined\r\n     tercero tenemos las claves que no son undefined , necesitamos el objeto entero  */\n    const params = Object.keys(listparams).filter(key => listparams[key] !== undefined).reduce((prev, next) => ({ ...prev,\n      [next]: listparams[next]\n    }), {}); //Metodo estandarizado usando urlsearchparams\n\n    const querystring = new URLSearchParams(params).toString();\n    url = url + '?' + querystring;\n  }\n\n  return UseGet(url);\n};\n_c2 = UseGetRecipesList;\nexport const UseRecipe = id => {\n  _s2();\n\n  /*La forma mas basica de traernos el contenido de la api es utilizando un usestate para recoger valores y \r\n  y un useeffect para ejecutar el fetch y dando el valor de la response al set \r\n  En este segundo caso usamos la id para traernos una receta en concreto por su identificador */\n  const [response, setResponse] = useState({});\n  useEffect(() => {\n    fetch('http://localhost:8000/recipes/' + id, {\n      method: 'GET',\n      ...options\n    }).then(response => response.json()).then(response => {\n      setResponse(response);\n    });\n  }, [id]);\n  return response;\n}; //Como el body lo recibimos desde el formulario el retorno del valor no vendra dado en la funcion sino como parametro de retorno\n\n_s2(UseRecipe, \"PPdBA4WNWUy55EY/yE+UpOAsHy0=\");\n\n_c3 = UseRecipe;\nexport const UseCreateRecipe = () => {\n  _s3();\n\n  const [loading, setloading] = useState(false);\n  return {\n    createRecipes: body => {\n      setloading(true);\n      return fetch('http://localhost:8000/recipes/', {\n        method: 'POST',\n        body: JSON.stringify(body),\n        ...options\n      }).then(response => response.json()).then(response => {\n        setloading(false);\n        return response;\n      });\n    },\n    loading\n  };\n}; //HOOK EDIT \n\n_s3(UseCreateRecipe, \"cN4OSKerpuIxwcw0ITosEp2MRVA=\");\n\n_c4 = UseCreateRecipe;\nexport const UseEditRecipe = id => {\n  _s4();\n\n  const [loading, setloading] = useState(false);\n  return {\n    editRecipes: body => {\n      setloading(true);\n      return fetch('http://localhost:8000/recipes/' + id, {\n        method: 'PUT',\n        body: JSON.stringify(body),\n        ...options\n      }).then(response => response.json()).then(response => {\n        setloading(false);\n        return response;\n      });\n    },\n    loading\n  };\n};\n\n_s4(UseEditRecipe, \"cN4OSKerpuIxwcw0ITosEp2MRVA=\");\n\n_c5 = UseEditRecipe;\nexport const UseDeleteRecipe = id => {\n  return () => fetch('http://localhost:8000/recipes/' + id, {\n    method: 'DELETE'\n  });\n};\n_c6 = UseDeleteRecipe;\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"UseGet\");\n$RefreshReg$(_c2, \"UseGetRecipesList\");\n$RefreshReg$(_c3, \"UseRecipe\");\n$RefreshReg$(_c4, \"UseCreateRecipe\");\n$RefreshReg$(_c5, \"UseEditRecipe\");\n$RefreshReg$(_c6, \"UseDeleteRecipe\");","map":{"version":3,"sources":["C:/Pablo/proyectosmaster/SEMANA 7/FRONTEND USE DATABASES RECIPES WEEK 6 (victor)/frontrecipes/src/hooks/api/index.js"],"names":["useEffect","useState","hostname","options","headers","UseGet","url","response","setResponse","fetch","method","then","json","UseGetRecipesList","listparams","params","Object","keys","filter","key","undefined","reduce","prev","next","querystring","URLSearchParams","toString","UseRecipe","id","UseCreateRecipe","loading","setloading","createRecipes","body","JSON","stringify","UseEditRecipe","editRecipes","UseDeleteRecipe"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\";\r\n\r\nconst hostname = 'http://localhost:8000';\r\n/*El options nos permite aplicar los headers a las llamadas asegurandonos de que nuestra comunicacion\r\nes en JSON */\r\nconst options = {\r\n    headers:{\r\n        'Content-Type':'application/json',\r\n        'Accepts':'application/json',\r\n    }\r\n}\r\n/*como se repite la misma estructura practicamente en todos los procesos hemos \r\ncreado un UseGET con ella */\r\n\r\nexport const UseGet = (url) =>{\r\n    const [response,setResponse]=useState();\r\nuseEffect ( () => {\r\n        fetch(hostname + url,\r\n        {\r\n            method:'GET',\r\n            ...options,\r\n        }).then(response => response.json())\r\n        .then(response => {\r\n            setResponse(response);\r\n            \r\n        })\r\n    },[url]);\r\n    \r\n    return response;\r\n}\r\n\r\n\r\n/* 1* uso del get sin el useget para tener como referencia */\r\n/*\r\nexport const UseGetRecipesList = () => {\r\nLa forma mas basica de traernos el contenido de la api es utilizando un usestate \r\npara recoger valores y  un useeffect para ejecutar el fetch y dando el valor de \r\nla response al set \r\n\r\nconst [response,setResponse]=useState();\r\nuseEffect ( () => {\r\n        fetch('http://localhost:8000/recipes',\r\n        {\r\n            method:'GET',\r\n            ...options,\r\n        }).then(response => response.json())\r\n        .then(response => {\r\n            setResponse(response);\r\n            \r\n        })\r\n    },[]);\r\n    return response;\r\n}\r\n\r\n*/\r\n\r\n//GET usando useget y implementando el buscador de keywords\r\n/*2 uso del useget en get recipes export const UseGetRecipesList = () => UseGet('/recipes');\r\n}\r\nexport const UseGetRecipesList = (keywords) =>{\r\n    let url = '/recipes';\r\n    if(keywords){\r\n     url =  url + '?keywords=' + keywords;\r\n    }\r\n    return UseGet(url);\r\n}\r\n*/\r\n//3* uso del usegetrecipes para trabajar correctamente con las urls y gestion de errores \r\n\r\nexport const UseGetRecipesList = (listparams) =>{\r\n    let url = '/recipes';\r\n    \r\n    if(listparams){\r\n    //metodo elaborado usando Object ,encode y reduce\r\n    //const querystring = Object.keys(listparams).map(key => key +'='+ encodeURIComponent(listparams[key])).redude((a,b) => a +'&'+ b)\r\n    /*el const params recomponemos el objeto , primero sacamos las claves , segundo en un filter excluimos las undefined\r\n     tercero tenemos las claves que no son undefined , necesitamos el objeto entero  */\r\n    const params = Object.keys(listparams)\r\n    .filter(key=>listparams[key] !==undefined)\r\n    .reduce((prev ,next) => ({...prev,[next]:listparams[next]}),{});\r\n    //Metodo estandarizado usando urlsearchparams\r\n    const querystring = new URLSearchParams(params).toString();\r\n     url =  url + '?' + querystring;\r\n    }\r\n    return UseGet(url);\r\n}\r\n\r\n\r\nexport const UseRecipe = (id) => {\r\n    /*La forma mas basica de traernos el contenido de la api es utilizando un usestate para recoger valores y \r\n y un useeffect para ejecutar el fetch y dando el valor de la response al set \r\n En este segundo caso usamos la id para traernos una receta en concreto por su identificador */\r\n \r\n const [response,setResponse]=useState({});\r\n useEffect ( () => {\r\n         fetch('http://localhost:8000/recipes/'+ id,\r\n         {\r\n             method:'GET',\r\n             ...options,\r\n         }).then(response => response.json())\r\n         .then(response => {\r\n             setResponse(response);  \r\n         })\r\n     },[id]);\r\n     \r\n     return response;\r\n}\r\n//Como el body lo recibimos desde el formulario el retorno del valor no vendra dado en la funcion sino como parametro de retorno\r\nexport const UseCreateRecipe = () => {\r\n    const [loading,setloading]= useState(false);\r\n    return {\r\n        createRecipes: (body) => {\r\n            setloading(true);\r\n            return fetch('http://localhost:8000/recipes/',{\r\n                method:'POST',\r\n                body:JSON.stringify(body),\r\n                ...options,\r\n                }).then(response => response.json())\r\n                .then(response =>{\r\n                    setloading(false);\r\n                    return response;\r\n                })\r\n        },\r\n        loading,\r\n    }   \r\n}\r\n\r\n \r\n//HOOK EDIT \r\n\r\nexport const UseEditRecipe = (id) => {\r\n    const [loading,setloading]= useState(false);\r\n    return {\r\n        editRecipes: (body) => {\r\n            setloading(true);\r\n            return fetch('http://localhost:8000/recipes/'+ id,{\r\n                method:'PUT',\r\n                body:JSON.stringify(body),\r\n                ...options,\r\n                }).then(response => response.json())\r\n                .then(response =>{\r\n                    setloading(false);\r\n                    return response;\r\n                })\r\n        },\r\n        loading,\r\n    }   \r\n}\r\n\r\n\r\n\r\n\r\nexport const UseDeleteRecipe = (id) => {\r\n return () => \r\n  fetch('http://localhost:8000/recipes/'+ id,\r\n    {\r\n     method:'DELETE',\r\n    })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}